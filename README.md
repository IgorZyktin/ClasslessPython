# ClasslessPython

Скрипт в стиле ООП, но без классов. Как на ванильном js. Мне захотелось повторить встроенные механизмы python, но самому, без помощи языка.
В результате получился код, который, с точки зрения пользователя, работает как обычный, но таковым не является.

### Пример использования

```
    >>> parrot = Parrot(name='Poppy')
    >>> cat = Cat(name='Whiskers')
    >>> parrot.legs
    2
    >>> cat.legs
    4
    >>> cat.say()
    'Meow!'
    >>> parrot.say()
    'Ara! ara!'
    >>> isinstance(parrot, Animal)
    True
    >>> isinstance(parrot, Cat)
    False
    >>> cat.call('Bobby')
    'no reaction'
    >>> cat.call('Whiskers')
    'Meow!'
    >>> type(parrot)
    inst of Parrot
    >>> type(Parrot)
    class Parrot
```

### Как это работает

В лучших традициях седой древности, мы создаём структуру, в которую кладём данные и функции по их обработке. 
На этом этапе уже можно использовать вызовы вида Cat.call(cat, 'Bobby). 
Но это не очень удобно для использования, поэтому тут я был вынужден немного воспользоваться встроенной магией интерпретатора, чтобы преобразовать вызов в cat.call('Bobby'). 
Мы ведь отказываемся от применения питоновских функций в качестве дескрипторов не-данных, поэтому экземпляр класса приходится
класть в функцию собственноручно. 
На выходе получается нечто, очень похожее на bound method в самом языке. Хотя у настоящих методов конечно присутствует кеширование.

Подобная примитивная реализация даже позволяет делать наследование и переопределение методов, правда без алгоритма линеаризации для множественного наследования.

### Практический смысл

Никакого. Просто упражнение для понимания работы классов/метаклассов и реализации ООП в Python.


### Чем это плохо

Всем. Строго говоря, это примерно так и реализовано в самом Python (а если копнуть глубже, то и в C/C++). 
Но там это очень долго доводилось до ума и тестировалось. Потребуется потратить очень много человекочасов, 
чтобы выдать схему соизмеримую по надёжности. Фактически, при попытке написать подобную систему самостоятельно, 
придётся просто-напросто повторить большие куски функционала самого языка. Основная проблема в том, что мы выходим 
на территорию запредельного полиморфизма, фактически теряя типизацию и можем творить что-попало. Можем вызывать 
конструкторы не тех классов, которых хотим, находить нужные методы не у того предка, как попало обращаться с сигнатурами. 
Все эти проблемы уже были решены в прошлом, эти решения были интегрированы в сам язык и в IDE, так что пытаться отойти от этого - 
быть самому себе злобным буратиной.
